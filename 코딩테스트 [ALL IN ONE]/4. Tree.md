# Tree

## ì¬ê·€ (Recursion)

> ì¬ê·€í•¨ìˆ˜(Recursive function)

ì¬ê·€í•¨ìˆ˜ë€ ìì‹ ì„ ì •ì˜í•  ë•Œ ìê¸° ìì‹ ì„ ì¬ ì°¸ì¡°í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§í•œë‹¤.

ë‹¤ìŒì€ ëŒ€í‘œì ì¸ ë‘ ê°€ì§€ ì¬ê·€í•¨ìˆ˜.

```python
def factorial(n)
    if n == 1:
        return 1
    return n * factorial(n-1)

print(factorial(4))  # 24
```

```python
def fibonacci(n):
    if n == 1 or 2:
        return 1
    return fibonacci(n-2) + fibonacci(n-1)
```

<br/>

> ì¬ê·€í•¨ìˆ˜ì˜ êµ¬ì„±ìš”ì†Œ

1. ì í™”ì‹(recurrence relation)

fnì„ f(n-1),f(n-2),...,f(2),f(1)ì˜ ê´€ê³„ì‹ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²ƒì„ ë§í•œë‹¤. <br/>
(problemê³¼ subproblemì˜ ê´€ê³„ì‹)

ex.1) Factorial: f(n) = n \* f(n-1) <br/>
ex.2) Fibonacci: f(n) = f(n-1) + f(n-2)
<br/>

2. base case

ë”ì´ìƒ ì¬ê·€í˜¸ì¶œì„ í•˜ì§€ ì•Šì•„ë„ ê³„ì‚°ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆëŠ” ìƒí™©ì„ ë§í•œë‹¤. <br/>
ëª¨ë“  ì…ë ¥ì´ ìµœì¢…ì ìœ¼ë¡œ base caseë¥¼ ì´ìš©í•´ì„œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. <br/>
base caseê°€ ìˆì–´ì•¼ ì¬ê·€í•¨ìˆ˜ì˜ ë¬´í•œ ë£¨í”„ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.

<br/>

> ì¬ê·€í•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„

ì¬ê·€ í•¨ìˆ˜ ì „ì²´ ì‹œê°„ë³µì¡ë„ = ì¬ê·€ í•¨ìˆ˜ í˜¸ì¶œ ìˆ˜ x (ì¬ê·€ í•¨ìˆ˜ í•˜ë‚˜ë‹¹) ì‹œê°„ë³µì¡ë„

<br/>

- O(n) <br/>
  nì— ë¹„ë¡€í•œ í˜¸ì¶œ: f(n) = f(n-1) + n

- O(2^n) <br/>
  2^nì— ë¹„ë¡€í•œ í˜¸ì¶œ: f(n) = f(n-1) + f(n-3)

- O(log2n) <br/>
  ex) Binary Search

<br/>

## íŠ¸ë¦¬ (Tree)

> íŠ¸ë¦¬

TreeëŠ” ì„œë¡œ ì—°ê²°ëœ Nodeì˜ **ê³„ì¸µí˜• ìë£Œêµ¬ì¡°**ë¡œì¨, rootì™€ ë¶€ëª¨-ìì‹ ê´€ê³„ì˜ subtreeë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤. <br/>
ê° ë…¸ë“œëŠ” Value, LC(Left Child), RC(Right Child)ë¡œ êµ¬ì„±ëœë‹¤.

<br/>

> Treeê´€ë ¨ ê°œë…

|        ëª…ì¹­        |                               ì„¤ëª…                                |
| :----------------: | :---------------------------------------------------------------: |
|     ë…¸ë“œ(Node)     |                       íŠ¸ë¦¬ë¥¼ êµ¬ë¶„í•˜ëŠ” ë‹¨ìœ„                        |
|     ê°„ì„ (Edge)     |                         ë…¸ë“œê°„ ì—°ê²°ëœ ì„                           |
|  ë£¨íŠ¸ ë…¸ë“œ(Root)   |                           íŠ¸ë¦¬ì˜ ì‹œì‘ì                            |
|  ë¦¬í”„ ë…¸ë“œ(Leaf)   |                ë”ì´ìƒ ë»—ì–´ë‚˜ê°ˆ ìˆ˜ ì—†ëŠ” ë§ˆì§€ë§‰ ë…¸ë“œ                |
|  ìì‹ ë…¸ë“œ(Child)  |                              (ìƒëµ)                               |
| ë¶€ëª¨ ë…¸ë“œ(Parent)  |                              (ìƒëµ)                               |
| í˜•ì œ ë…¸ë“œ(Sibling) |                              (ìƒëµ)                               |
|    ì°¨ìˆ˜(degree)    |                     ê° ë…¸ë“œê°€ ê°–ëŠ” ìì‹ì˜ ìˆ˜                      |
|   ì¡°ìƒ(ancestor)   |             ìœ„ìª½ìœ¼ë¡œ ê°„ì„ ì„ ë”°ë¼ê°€ë©´ ë§Œë‚˜ëŠ” ëª¨ë“  ë…¸ë“œ             |
|  ìì†(descendant)  |            ì•„ë˜ìª½ìœ¼ë¡œ ê°„ì„ ì„ ë”°ë¼ê°€ë©´ ë§Œë‚˜ëŠ” ëª¨ë“  ë…¸ë“œ            |
|    ë ˆë²¨(level)     |               ë£¨íŠ¸ ë…¸ë“œì—ì„œë¶€í„° ê±°ì³ì˜¨ ê°„ì„ ì˜ ê±°ë¦¬                |
|    ë†’ì´(height)    |         ë£¨íŠ¸ ë…¸ë“œì—ì„œ ê°€ì¥ ë©€ë¦¬ìˆëŠ” ë¦¬í”„ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬          |
| ì„œë¸ŒíŠ¸ë¦¬(subtree)  | íŠ¸ë¦¬ ë‚´ë¶€ ì„ì˜ì˜ ë…¸ë“œë¥¼ ë£¨íŠ¸ ë…¸ë“œë¡œ í•˜ê³ , ê·¸ ìì†ìœ¼ë¡œ êµ¬ì„±ëœ íŠ¸ë¦¬ |

<br/>

> ì´ì§„ íŠ¸ë¦¬ (Binary Tree)

ëª¨ë“  ë…¸ë“œì˜ ì°¨ìˆ˜ê°€ nê°œ ì´í•˜ì¸ íŠ¸ë¦¬ë¥¼ nì§„ íŠ¸ë¦¬ë¼ê³  í•¨. <br/>
(ë³´í†µ ì´ì§„ íŠ¸ë¦¬(Binary Tree)ì˜ ì‚¬ìš©ì´ ë§ìŒ)

```python
class Node:
    def __init__(self, value = 0, left = None, right = None):
        self.value = value
        self.left_child = left
        self.right_child = right

class BinaryTree:
    def __init__(self):
        self.root = None

binary_tree = BinaryTree()
binary_tree.root = Node(value = 1)
binary_tree.left = Node(value = 2)
binary_tree.right = Node(value = 3)
binary_tree.left.left = Node(value = 4)
binary_tree.left.right = Node(value = 5)
binary_tree.right.left = Node(value = 5)
binary_tree.right.right = Node(value = 6)
```

<br/>

> ì™„ì „ ì´ì§„ íŠ¸ë¦¬ (Compelete Binary Tree)

ë…¸ë“œë¥¼ ì±„ìš°ëŠ” ìˆœì„œê°€ ì •í•´ì ¸ ìˆìŒ.

ë†’ì´ê°€ hì¼ ë•Œ, h-1ê¹Œì§€ëŠ” Full Binary Treeì´ë©° <br/>
ë ˆë²¨ hì—ì„œëŠ” ì™¼ìª½ë¶€í„° ë…¸ë“œê°€ ìˆœì„œëŒ€ë¡œ ì±„ì›Œì§„ ì´ì§„íŠ¸ë¦¬.

<br/>

## Traversal 1 - Level order

> íŠ¸ë¦¬ ìˆœíšŒ (Tree Traversal)

íŠ¸ë¦¬ ìˆœíšŒë€ íŠ¸ë¦¬ íƒìƒ‰ì´ë¼ê³ ë„ ë¶ˆë¦¬ìš°ë©° íŠ¸ë¦¬ì˜ ê° ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ëŠ” ê³¼ì •ì„ ë§í•œë‹¤. <br/>
ëª¨ë“  ë…¸ë“œë¥¼ í•œ ë²ˆì”© ë°©ë¬¸ í•´ì•¼ í•˜ë¯€ë¡œ ì™„ì „ íƒìƒ‰ì´ë¼ê³ ë„ í•  ìˆ˜ ìˆë‹¤.

ìˆœíšŒ ë°©ë²•ìœ¼ë¡œëŠ” ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì¸ BFSì™€ ê¹Šì´ ìš°ì„  íƒìƒ‰ì¸ DFSê°€ ìˆë‹¤.

<br/>

> BFS

```python
from collections import deque

def bfs(root):
    visited = []
    if root is None:
        return []
    queue = deque() # bfsë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ queue ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
    queue.append(root)

    while queue:
        cur_node = queue.popleft()
        visited.append(cur_node.value)

        if cur_node.left:
            queue.append(cur_node.left)
        if cur_node.right:
            queue.append(cur_node.right)

    return visited
```

ìœ„ì˜ ì½”ë“œëŠ” í…œí”Œë¦¿í™” í•˜ì—¬ ë°”ë¡œ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ ì²´í™”í•´ì•¼ í•œë‹¤. <br/>
ê·¸ë˜ì•¼ í™œìš©í•˜ëŠ” ì½”ë“œë„ ë¹¨ë¦¬ ì‘ì„±í•  ìˆ˜ ìˆìŒ

<br/>

## Traversal 2 - ì „ìœ„ ìˆœíšŒ (Preorder), ì¤‘ìœ„ ìˆœíšŒ (Inorder), í›„ìœ„ ìˆœíšŒ (Postorder)

> DFS

DFSëŠ” Stackê³¼ ë°˜ë³µë¬¸ì„ ì´ìš©í•˜ëŠ” ë°©ë²•, Recursionì„ ì´ìš©í•˜ëŠ” ë°©ë²• ë‘ ê°€ì§€ê°€ ì¡´ì¬í•œë‹¤. <br/>
ë³´í†µì˜ ê²½ìš° Recursionì´ ë” ìì£¼ ì‚¬ìš©ëœë‹¤.

```python
def dfs(cur_node):
    if cur_node is None:
        return

    dfs(cur_node.left)
    dfs(cur_node.right)

dfs(root)
```

<br/>

## Traversal 3 - ì „ìœ„ ìˆœíšŒ (Preorder), ì¤‘ìœ„ ìˆœíšŒ (Inorder), í›„ìœ„ ìˆœíšŒ (Postorder)

DFSë¡œ ì‹¤ì§ˆì ì¸ ë°©ë¬¸ì„ í•˜ëŠ” ë°©ë²•ì„ ì‘ì„±í•œë‹¤.

A-(B(-D(-G,H),E),C(-_,F)) <br/>
A - B/C <br/>
B - D/E <br/>
C - _/F <br/>
D - G/H

ìœ„ êµ¬ì¡°ì˜ íŠ¸ë¦¬ì— ëŒ€í•´, ê°ê°ì˜ ìˆœíšŒ ë°©ì‹ë§ˆë‹¤ ì–´ë–»ê²Œ ë°©ë¬¸ ìˆœì„œê°€ ë‹¬ë¼ì§€ëŠ”ì§€ í™•ì¸.

> ì „ìœ„ ìˆœíšŒ (Preorder)

```python
def preorder(cur_node):
    if cur_node is None:
        return

    # ì ‘ê·¼ í•˜ìë§ˆì ë°©ë¬¸
    print(cur_node.value)  # ë°©ë¬¸ í–‰ìœ„ ìì²´ë¥¼ í‘œí˜„
    preorder(cur_node.left)
    preorder(cur_node.right)

preorder(root)
```

ë°©ë¬¸ ìˆœì„œ : A B D G H E C F <br/>
ìƒ->ì¢Œ ìš°ì„  ìƒ‰ì¹ 

<br/>

> ì¤‘ìœ„ ìˆœíšŒ(Inorder)

```python
def inorder(cur_node):
    if cur_node is None:
        return

    inorder(cur_node.left)
    # LCí˜¸ì¶œê³¼ RCí˜¸ì¶œ ì‚¬ì´ì—ì„œ ë°©ë¬¸
    print(cur_node.value)  # ë°©ë¬¸ í–‰ìœ„ ìì²´ë¥¼ í‘œí˜„
    inorder(cur_node.right)

inorder(root)
```

ë°©ë¬¸ ìˆœì„œ : G D H B E A C F <br/>
ì¢Œ->(ë¶€ë¶„)ìƒ ìš°ì„  ìƒ‰ì¹ 

<br/>

> í›„ìœ„ ìˆœíšŒ(Postorder)

```python
def postorder(cur_node):
    if cur_node is None:
        return

    postorder(cur_node.left)
    postorder(cur_node.right)
    # LCí˜¸ì¶œ, RCí˜¸ì¶œ ëª¨ë‘ ëë‚¸ í›„ ë°©ë¬¸
    print(cur_node.value)  # ë°©ë¬¸ í–‰ìœ„ ìì²´ë¥¼ í‘œí˜„

postorder(root)
```

ë°©ë¬¸ ìˆœì„œ : G H D E B F C A <br/>
ì¢Œ->(ë¶€ë¶„)ìš° ìš°ì„  ìƒ‰ì¹ 

<br/>

## [ì½”í…Œ ì ìš©] ğŸ‘‰ Postorder

> Lowest Common Ancestor of a Binary Tree

[https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/) ë¬¸ì œ í’€ì´.

<br/>

## [ì½”í…Œ ì ìš©] ğŸ‘‰ level order traversal

> Maximum Depth of Binary Tree

~~[https://leetcode.com/problems/maximum-depth-of-binary-tree/](https://leetcode.com/problems/maximum-depth-of-binary-tree/) ë¬¸ì œ í’€ì´. (ì™„)~~

BFS, DFS ë‘ ê°€ì§€ ë°©ì‹ìœ¼ë¡œ ëª¨ë‘ í•´ê²°í•  ê²ƒ.

<br/>
